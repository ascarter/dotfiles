#!/bin/sh

# Generate git config global file

log() {
  if [ "$#" -eq 1 ]; then
    printf "%s\n" "$1"
  elif [ "$#" -gt 1 ]; then
    printf "$(tput bold)%-10s$(tput sgr0)\t%s\n" "$1" "$2"
  fi
}

# verbose log
vlog() {
  if [ $verbose -eq 1 ]; then
    log "$@"
  fi
}

usage() {
  log "gitconfig -- Generate git config"
  log "Usage: gitconfig [options] [config file path]"
  log ""
  log "Options:"
  log "  -u" "Unset all values set by gitconfig"
  log "  -f" "Replace existing config file"
  log "  -v" "Verbose"
}

gc_get() {
  $GIT_CMD --get "$1"
}

gc_set() {
  if [ $unset -eq 1 ]; then
    vlog "skip" "set $1=$2"
    return
  fi

  vlog "set" "$1 = $2"
  $GIT_CMD "$1" "$2"
}

gc_add() {
  if [ $unset -eq 1 ]; then
    vlog "skip" "add $1=$2"
    return
  fi

  vlog "add" "$1 = $2"
  $GIT_CMD --add "$1" "$2"
}

gc_unset() {
  vlog "unset" "$1"
  $GIT_CMD --unset "$1"
}

gc_clear() {
  vlog "clear" "$1"
  $GIT_CMD --unset-all "$1"
}

# Prompt for git config key
# Parameters:
#   $1 == key
#   $2 == default value
gc_prompt() {
  curr=$($GIT_CMD --get "$1")
  input="${curr:-$2}"
  printf "$1: "
  # read -e -i is not POSIX, we need to handle default values manually
  if [ -n "$input" ]; then
    printf "[%s] " "$input"
  fi
  read -r user_input
  # Use user input if provided, otherwise use default
  if [ -z "$user_input" ]; then
    user_input="$input"
  fi
  gc_set "$1" "$user_input"
}

gc_tools() {
  gc_clear diff.guitool
  gc_clear merge.guitool

  if [ $unset -eq 1 ]; then
    vlog "skip" "Git tools"
    return
  fi

  # Use opendiff on macOS for gui diff/merge tools
  if command -v opendiff >/dev/null 2>&1; then
    gc_set diff.tool "opendiff"
    gc_set diff.guitool "opendiff"
    gc_set merge.tool "opendiff"
    gc_set merge.guitool "opendiff"
  fi
}

gc_user() {
  # Get user info from current file
  username=$(gc_get "user.name")
  email=$(gc_get "user.email")

  # Clear user
  gc_unset user.name
  gc_unset user.email

  if [ $unset -eq 1 ]; then
    vlog "skip" "Git user"
    return
  fi

  gc_prompt user.name "${username:-${USER:-$(whoami)}}"
  gc_prompt user.email "${email:-${ghuser:-${USER:-$(whoami)}}@users.noreply.github.com}"
}

# Configure git credential managers
gc_credentials() {
  # Clear default credential helper
  gc_clear credential.helper

  git_cred_helper=""
  if command -v gh >/dev/null 2>&1; then
    log "credentials" "gh"
    gh auth setup-git
    # git_cred_helper="!$(command -v gh) auth git-credential"
  elif command -v git-credential-manager >/dev/null 2>&1; then
    log "credentials" "gcm"
    git-credential-manager configure
    # git_cred_helper="$(command -v git-credential-manager)"
  else
    case $(uname) in
    Darwin)
      log "credentials" "osxkeychain"
      git_cred_helper="osxkeychain"
      ;;
    Linux)
      log "credentials" "cache"
      git_cred_helper="cache"
      ;;
    esac
    gc_add credential.helper "$git_cred_helper"
  fi

  # Configure Azure DevOps if GCM is installed
  if command -v git-credential-manager >/dev/null 2>&1; then
    az_urls="https://dev.azure.com https://*.visualstudio.com"
    for url in $az_urls; do
      gc_clear credential.${url}.helper
      gc_clear credential.${url}.useHttpPath
      gc_clear credential.azreposCredentialType

      gc_add credential.${url}.helper ''
      gc_add credential.${url}.helper $(command -v git-credential-manager)
      gc_set credential.${url}.useHttpPath true
      gc_set credential.${url}.azreposCredentialType oauth
    done
  fi
}

gc_commitsigning() {
  # Clear signing keys
  gc_clear user.signingkey
  gc_clear gpg.format
  gc_clear gpg.ssh.program
  gc_clear commit.gpgsign
  gc_clear gpg.ssh.allowedSignersFile

  if [ $unset -eq 1 ]; then
    vlog "skip" "Commit signing keys"
    return
  fi

  # Configure commit signing using SSH
  # Get public key from attached YubiKey resident SSH key
  signing_key=""
  if command -v ssh-add >/dev/null 2>&1; then
    # Try to get YubiKey public key from ssh-agent
    signing_key=$(ssh-add -L 2>/dev/null | grep -E "(sk-|ecdsa-sk|ed25519-sk)" | head -n1)
  fi

  # Fallback: check for downloaded resident keys
  if [ -z "$signing_key" ] && [ -f ~/.ssh/id_ed25519_sk.pub ]; then
    signing_key=$(cat ~/.ssh/id_ed25519_sk.pub)
  fi

  if [ -n "$signing_key" ]; then
    # Use ssh for signing. Requires SSH_AUTH_SOCK to be set
    log "signingkey" "$(echo "$signing_key" | cut -d' ' -f1-2)"
    gc_set user.signingkey "$signing_key"
    gc_set gpg.format ssh
    gc_set commit.gpgsign true
  fi

  if [ -n "${ghuser}" ]; then
    if command -v gh >/dev/null 2>&1; then
      # Download signing keys from GitHub
      signers="$HOME/.ssh/allowed_signers"
      signing_keys=$(gh api users/${ghuser}/ssh_signing_keys --jq '.[] | .key | @text')

      # Use POSIX-compliant loop
      echo "$signing_keys" | while read -r pubkey; do
        if ! grep -q -F "$pubkey" "$signers" 2>/dev/null; then
          # Add the key, narrowly scoped for Git
          log "add" "Signing key ${pubkey} for ${ghuser}"
          mkdir -p "$(dirname "${signers}")"
          echo "${ghuser} namespaces=\"git\" ${pubkey}" >>${signers}
        else
          vlog "exists" "Signing key ${pubkey} for ${ghuser}"
        fi
      done

      if [ -s ${signers} ]; then
        gc_set gpg.ssh.allowedSignersFile "$signers"
      fi
    fi
  fi
}

gc_lfs() {
  if command -v git-lfs >/dev/null 2>&1; then
    git lfs install
  fi
}

# Main script function

# Parse command line arguments
verbose=0
force=0
unset=0

while getopts "fhuv" opt; do
  case ${opt} in
  f) force=1 ;;
  u) unset=1 ;;
  v) verbose=1 ;;
  h) usage && exit 0 ;;
  \?) usage && exit 1 ;;
  esac
done
shift $((OPTIND - 1))

GIT_CONFIG_FILE=${1:-${GIT_CONFIG_FILE:-${HOME}/.gitconfig}}
GIT_CMD="git config --file $GIT_CONFIG_FILE"

# Get the GitHub username if gh command is available
ghuser=""
if command -v gh >/dev/null 2>&1; then
  ghuser=$(gh api user --jq '.login')
fi

if [ $force -eq 1 ]; then
  echo "Removing existing ${GIT_CONFIG_FILE}"
  rm "${GIT_CONFIG_FILE}"
fi
touch "${GIT_CONFIG_FILE}"

vlog "config file" "${GIT_CONFIG_FILE}"
gc_user
gc_credentials
gc_commitsigning
gc_tools
gc_lfs
