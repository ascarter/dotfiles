#!/bin/sh

# Generate git config global file

log() {
  if [ "$#" -eq 1 ]; then
    printf "%s\n" "$1"
  elif [ "$#" -gt 1 ]; then
    printf "$(tput bold)%-10s$(tput sgr0)\t%s\n" "$1" "$2"
  fi
}

# verbose log
vlog() {
  if [ $verbose -eq 1 ]; then
    log "$@"
  fi
}

usage() {
  log "gitconfig -- Generate git config"
  log "Usage: gitconfig [options] [config file path]"
  log ""
  log "Options:"
  log "  -u" "Unset all values set by gitconfig"
  log "  -f" "Replace existing config file"
  log "  -v" "Verbose"
}

gc_get() {
  $GIT_CMD --get "$1"
}

gc_set() {
  if [ $unset -eq 1 ]; then
    vlog "skip" "set $1=$2"
    return
  fi

  vlog "set" "$1 = $2"
  $GIT_CMD "$1" "$2"
}

gc_add() {
  if [ $unset -eq 1 ]; then
    vlog "skip" "add $1=$2"
    return
  fi

  vlog "add" "$1 = $2"
  $GIT_CMD --add "$1" "$2"
}

gc_unset() {
  vlog "unset" "$1"
  $GIT_CMD --unset "$1"
}

gc_clear() {
  vlog "clear" "$1"
  $GIT_CMD --unset-all "$1"
}

# Prompt for git config key
# Parameters:
#   $1 == key
#   $2 == default value
gc_prompt() {
  curr=$($GIT_CMD --get "$1")
  input="${curr:-$2}"
  printf "$1: "
  # read -e -i is not POSIX, we need to handle default values manually
  if [ -n "$input" ]; then
    printf "[%s] " "$input"
  fi
  read -r user_input
  # Use user input if provided, otherwise use default
  if [ -z "$user_input" ]; then
    user_input="$input"
  fi
  gc_set "$1" "$user_input"
}

gc_tools() {
  gc_clear diff.guitool
  gc_clear merge.guitool

  if [ $unset -eq 1 ]; then
    vlog "skip" "Git tools"
    return
  fi

  # Use opendiff on macOS for gui diff/merge tools
  if command -v opendiff >/dev/null 2>&1; then
    gc_set diff.tool "opendiff"
    gc_set diff.guitool "opendiff"
    gc_set merge.tool "opendiff"
    gc_set merge.guitool "opendiff"
  fi
}

gc_user() {
  # Get user info from current file
  username=$(gc_get "user.name")
  email=$(gc_get "user.email")

  # Clear user
  gc_unset user.name
  gc_unset user.email

  if [ $unset -eq 1 ]; then
    vlog "skip" "Git user"
    return
  fi

  gc_prompt user.name "${username:-${USER:-$(whoami)}}"
  gc_prompt user.email "${email:-${ghuser:-${USER:-$(whoami)}}@users.noreply.github.com}"
}

# Configure git credential managers
gc_credentials() {
  # Clear default credential helper
  gc_clear credential.helper

  git_cred_helper=""
  if command -v gh >/dev/null 2>&1; then
    log "credentials" "gh"

    gh auth setup-git
    # git_cred_helper="!$(command -v gh) auth git-credential"
  elif command -v git-credential-manager >/dev/null 2>&1; then
    log "credentials" "gcm"
    git-credential-manager configure
    # git_cred_helper="$(command -v git-credential-manager)"
  else
    case $(uname) in
    Darwin)
      log "credentials" "osxkeychain"
      git_cred_helper="osxkeychain"
      ;;
    Linux)
      log "credentials" "cache"
      git_cred_helper="cache"
      ;;
    esac
    gc_add credential.helper "$git_cred_helper"
  fi

  # Configure Azure DevOps if GCM is installed
  if command -v git-credential-manager >/dev/null 2>&1; then
    az_urls="https://dev.azure.com https://*.visualstudio.com"
    for url in $az_urls; do
      gc_clear credential.${url}.helper
      gc_clear credential.${url}.useHttpPath
      gc_clear credential.azreposCredentialType

      gc_add credential.${url}.helper ''
      gc_add credential.${url}.helper $(command -v git-credential-manager)
      gc_set credential.${url}.useHttpPath true
      gc_set credential.${url}.azreposCredentialType oauth
    done
  fi
}

gc_commitsigning() {
  # Clear signing keys
  gc_clear user.signingkey
  gc_clear gpg.format
  gc_clear gpg.ssh.program
  gc_clear commit.gpgsign
  gc_clear gpg.ssh.allowedSignersFile

  if [ $unset -eq 1 ]; then
    vlog "skip" "Commit signing keys"
    return
  fi

  # Configure commit signing using GPG
  # Get GPG signing key from YubiKey
  signing_key_id=$(get_gpg_signing_key)
  if [ -n "$signing_key_id" ]; then
    # Use GPG for signing. This will prompt for YubiKey PIN when signing
    log "signingkey" "YubiKey GPG key: $signing_key_id"
    gc_set user.signingkey "$signing_key_id"
    gc_set commit.gpgsign true
    gc_set tag.gpgsign true
  else
    vlog "warning" "No YubiKey GPG signing key found"
  fi
}

# Get GPG signing key ID
get_gpg_signing_key() {
  if ! command -v gpg >/dev/null 2>&1; then
    return 1
  fi

  # Get the signing key ID from secret key list
  # Parse colon-separated output: find first secret subkey (ssb) with signing capability (s) and return key ID (field 5)
  signing_key=$(gpg --list-secret-keys --with-colons 2>/dev/null | awk -F: '/^ssb/ && $12 ~ /s/ {print $5; exit}')

  if [ -n "$signing_key" ]; then
    echo "$signing_key"
    return 0
  fi

  return 1
}

gc_lfs() {
  if command -v git-lfs >/dev/null 2>&1; then
    git lfs install
  fi
}

# Main script function

# Parse command line arguments
verbose=0
force=0
unset=0

while getopts "fhuv" opt; do
  case ${opt} in
  f) force=1 ;;
  u) unset=1 ;;
  v) verbose=1 ;;
  h) usage && exit 0 ;;
  \?) usage && exit 1 ;;
  esac
done
shift $((OPTIND - 1))

GIT_CONFIG_FILE=${1:-${GIT_CONFIG_FILE:-${HOME}/.gitconfig}}
GIT_CMD="git config --file $GIT_CONFIG_FILE"

# Get the GitHub username if gh command is available
ghuser=""
if command -v gh >/dev/null 2>&1; then
  ghuser=$(gh api user --jq '.login')
fi

if [ $force -eq 1 ]; then
  echo "Removing existing ${GIT_CONFIG_FILE}"
  rm "${GIT_CONFIG_FILE}"
fi
touch "${GIT_CONFIG_FILE}"

vlog "config file" "${GIT_CONFIG_FILE}"
gc_user
gc_credentials
gc_commitsigning
gc_tools
gc_lfs
