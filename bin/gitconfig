#!/bin/sh
# gitconfig.sh - generate git config global file

_gc_get() {
  git config --file "$1" --get "$2"
}

_gc_set() {
  git config --file "$1" "$2" "$3"
}

_gc_add() {
  git config --file "$1" --add "$2" "$3"
}

_gc_unset() {
  git config --file "$1" --unset "$2"
}

_gc_clear() {
  git config --file "$1" --unset-all "$2"
}

_gc_update() {
  _gc_unset "$1" "$2"
  if [ -n "$3" ]; then
    _gc_set "$1" "$2" "$3"
  fi
}

# Prompt for git config key
# Parameters:
#   $1 == gitconfig file
#   $2 == key
#   $3 == default value
_gc_prompt() {
  curr=$(git config --file "$1" --get "$2")
  input="${curr:-$3}"
  printf "%s: " "$2"
  # read -e -i is not POSIX, we need to handle default values manually
  if [ -n "$input" ]; then
    printf "[%s] " "$input"
  fi
  read -r user_input
  # Use user input if provided, otherwise use default
  if [ -z "$user_input" ]; then
    user_input="$input"
  fi
  _gc_update "$1" "$2" "$user_input"
}

# Configure git credential managers
_gc_credentials() {
  gitconfig_file=$1
  # Define URLs as space-separated strings
  gh_urls="https://github.com https://gist.github.com"
  az_urls="https://dev.azure.com https://*.visualstudio.com/"
  git_cred_helper=""

  if command -v op >/dev/null 2>&1; then
    echo "Use 1Password for GitHub"
    git_cred_helper="!op plugin run -- gh auth git-credential"
  elif command -v gh >/dev/null 2>&1; then
    echo "Use GitHub CLI"
    git_cred_helper="!gh auth git-credential"
  elif command -v git-credential-manager >/dev/null 2>&1; then
    echo "Use Git Credential Manager"
    git_cred_helper="git-credential-manager"
  else
    echo "Use keychain caching"
    case $(uname) in
    Darwin) git_cred_helper="osxkeychain" ;;
    Linux) git_cred_helper="cache" ;;
    esac
  fi

  # Clear default credential helper
  _gc_clear "$gitconfig_file" credential.helper

  # Configure GitHub
  for url in $gh_urls; do
    _gc_clear "$gitconfig_file" credential.${url}.helper
    _gc_add "$gitconfig_file" credential.${url}.helper ''
    _gc_add "$gitconfig_file" credential.${url}.helper "$git_cred_helper"
  done

  # Configure Azure DevOps if GCM is installed
  if command -v git-credential-manager >/dev/null 2>&1; then
    for url in $az_urls; do
      _gc_clear "$gitconfig_file" credential.${url}.helper
      _gc_add "$gitconfig_file" credential.${url}.helper ''
      _gc_add "$gitconfig_file" credential.${url}.helper git-credential-manager
      _gc_set "$gitconfig_file" credential.${url}.useHttpPath true
      _gc_set "$gitconfig_file" credential.azreposCredentialType oauth
    done
  fi

  # Clear gpg signing
  _gc_clear "$gitconfig_file" user.signingkey
  _gc_clear "$gitconfig_file" gpg.format
  _gc_clear "$gitconfig_file" gpg.ssh.program
  _gc_clear "$gitconfig_file" commit.gpgsign

  # Configure gpg signing
  if command -v op >/dev/null 2>&1; then
    # Use 1Password SSH for signing
    signing_key=$(op read "op://Private/GitHub SSH Key/public key")
    if [ -n "$signing_key" ]; then
      _gc_set "$gitconfig_file" user.signingkey "$signing_key"
      _gc_set "$gitconfig_file" gpg.format ssh
      # Use ssh for signing. Requires SSH_AUTH_SOCK to be set
      _gc_set "$gitconfig_file" commit.gpgsign true
    fi
  fi
}

_gc_signers() {
  gitconfig_file=$1
  ghuser=$2

  # Download signing keys from GitHub
  signers="$HOME/.ssh/allowed_signers"
  signing_keys=$(gh api users/${ghuser}/ssh_signing_keys --jq '.[] | .key | @text')

  # Use POSIX-compliant loop
  echo "$signing_keys" | while read -r pubkey; do
    if ! grep -q -F "$pubkey" "$signers" 2>/dev/null; then
      # Add the key, narrowly scoped for Git
      echo "Adding key ${pubkey} for user ${ghuser}"
      echo "${ghuser} namespaces=\"git\" ${pubkey}" >>${signers}
    else
      echo "Key ${pubkey} already exists for user ${ghuser}"
    fi
  done

  _gc_clear "$gitconfig_file" gpg.ssh.allowedSignersFile

  if [ -s ${signers} ]; then
    _gc_set "$gitconfig_file" gpg.ssh.allowedSignersFile "$signers"
  fi
}

_gc_tools() {
  # Use opendiff on macOS for gui diff/merge tools
  if command -v opendiff >/dev/null 2>&1; then
    _gc_set "$1" diff.guitool "opendiff"
    _gc_set "$1" merge.guitool "opendiff"
  fi
}

# Main script function

# Parse command line arguments
force=""
help=""

while [ $# -gt 0 ]; do
  case $1 in
  -f | --force)
    force="true"
    shift
    ;;
  -h | --help)
    help="true"
    shift
    ;;
  *)
    GIT_CONFIG_FILE="$1"
    shift
    ;;
  esac
done

# Show help
if [ -n "${help}" ]; then
  printf "%s -- Generate git config\nUsage: %s [-f|--force] [config file path]\n\n  -f, --force          replace existing config file if present\n" "$(basename "$0")" "$(basename "$0")"
  exit 1
fi

GIT_CONFIG_FILE=${GIT_CONFIG_FILE:-${HOME}/.gitconfig}

# Get the GitHub username if gh command is available
ghuser=""
if command -v gh >/dev/null 2>&1; then
  ghuser=$(gh api user --jq '.login')
fi

# Get user info from current file
username=$(_gc_get "$GIT_CONFIG_FILE" "user.name")
email=$(_gc_get "$GIT_CONFIG_FILE" "user.email")

if [ -n "${force}" ]; then
  echo "Removing existing ${GIT_CONFIG_FILE}"
  rm "${GIT_CONFIG_FILE}"
fi
touch "${GIT_CONFIG_FILE}"

echo "Generating ${GIT_CONFIG_FILE}"
_gc_prompt "$GIT_CONFIG_FILE" user.name "${username:-${USER:-$(whoami)}}"
_gc_prompt "$GIT_CONFIG_FILE" user.email "${email:-${ghuser:-${USER:-$(whoami)}}@users.noreply.github.com}"
_gc_credentials "$GIT_CONFIG_FILE"
_gc_tools "$GIT_CONFIG_FILE"

if [ -n "${ghuser}" ]; then
  echo "Download SSH signing keys from GitHub for user ${ghuser}"
  _gc_signers "$GIT_CONFIG_FILE" "${ghuser}"
fi

# vim: set ft=sh ts=2 sw=2 et:
