#!/bin/sh

# Generate git config global file

log() {
  if [ "$#" -eq 1 ]; then
    printf "%s\n" "$1"
  elif [ "$#" -gt 1 ]; then
    printf "$(tput bold)%-10s$(tput sgr0)\t%s\n" "$1" "$2"
  fi
}

# verbose log
vlog() {
  if [ $verbose -eq 1 ]; then
    log "$@"
  fi
}

usage() {
  log "gitconfig -- Generate git config"
  log "Usage: gitconfig [options] [config file path]"
  log ""
  log "Options:"
  log "  -f" "Replace existing config file"
  log "  -v" "Verbose"
}

gc_tools() {
  $GIT_CMD --unset-all diff.guitool 2>/dev/null || true
  $GIT_CMD --unset-all merge.guitool 2>/dev/null || true

  # Use opendiff on macOS for gui diff/merge tools
  if command -v opendiff >/dev/null 2>&1; then
    vlog "set" "opendiff for GUI diff/merge"
    $GIT_CMD diff.tool "opendiff"
    $GIT_CMD diff.guitool "opendiff"
    $GIT_CMD merge.tool "opendiff"
    $GIT_CMD merge.guitool "opendiff"
  fi
}

gc_user() {
  # Clear existing user config
  $GIT_CMD --unset user.name 2>/dev/null || true
  $GIT_CMD --unset user.email 2>/dev/null || true

  # Get full name from system
  if command -v id >/dev/null 2>&1; then
    fullname=$(id -F 2>/dev/null)
  fi

  # Fallback to other methods if id -F doesn't work
  if [ -z "$fullname" ]; then
    fullname=$(getent passwd "$USER" 2>/dev/null | cut -d: -f5 | cut -d, -f1)
  fi

  # Final fallback
  if [ -z "$fullname" ]; then
    fullname="$USER"
  fi

  # Require GitHub CLI to be logged in
  if ! command -v gh >/dev/null 2>&1; then
    log "error" "GitHub CLI (gh) is not installed"
    exit 1
  fi

  ghuser=$(gh api user --jq '.login' 2>/dev/null)
  if [ -z "$ghuser" ]; then
    log "error" "Not logged into GitHub CLI. Run 'gh auth login' first."
    exit 1
  fi

  email="${ghuser}@users.noreply.github.com"

  $GIT_CMD user.name "$fullname"
  $GIT_CMD user.email "$email"

  log "user" "$fullname <$email>"
}

# Configure git credential managers
gc_credentials() {
  # Clear default credential helper
  $GIT_CMD --unset-all credential.helper 2>/dev/null || true

  if command -v gh >/dev/null 2>&1; then
    log "credentials" "gh"
    gh auth setup-git
  elif command -v git-credential-manager >/dev/null 2>&1; then
    log "credentials" "gcm"
    git-credential-manager configure
  else
    case $(uname) in
    Darwin)
      log "credentials" "osxkeychain"
      $GIT_CMD --add credential.helper "osxkeychain"
      ;;
    Linux)
      log "credentials" "cache"
      $GIT_CMD --add credential.helper "cache"
      ;;
    esac
  fi

  # Configure Azure DevOps if GCM is installed
  if command -v git-credential-manager >/dev/null 2>&1; then
    az_urls="https://dev.azure.com https://*.visualstudio.com"
    for url in $az_urls; do
      $GIT_CMD --unset-all credential.${url}.helper 2>/dev/null || true
      $GIT_CMD --unset credential.${url}.useHttpPath 2>/dev/null || true
      $GIT_CMD --unset credential.azreposCredentialType 2>/dev/null || true

      vlog "add" "GCM credential helper for $url"
      $GIT_CMD --add credential.${url}.helper ''
      $GIT_CMD --add credential.${url}.helper $(command -v git-credential-manager)
      $GIT_CMD credential.${url}.useHttpPath true
      $GIT_CMD credential.${url}.azreposCredentialType oauth
    done
  fi
}

gc_commitsigning() {
  # Clear signing keys
  $GIT_CMD --unset-all user.signingkey 2>/dev/null || true
  $GIT_CMD --unset gpg.format 2>/dev/null || true
  $GIT_CMD --unset gpg.ssh.program 2>/dev/null || true
  $GIT_CMD --unset gpg.program 2>/dev/null || true
  $GIT_CMD --unset commit.gpgsign 2>/dev/null || true
  $GIT_CMD --unset tag.gpgsign 2>/dev/null || true
  $GIT_CMD --unset gpg.ssh.allowedSignersFile 2>/dev/null || true

  # Check if GPG is installed and configured
  if ! command -v gpg >/dev/null 2>&1; then
    log "warning" "GPG not installed - skipping commit signing configuration"
    return
  fi

  # Get the full path to gpg
  gpg_path=$(command -v gpg)

  # Get the signing key ID from YubiKey
  # Parse colon-separated output: find first secret subkey (ssb) with signing capability (s) and return key ID (field 5)
  signing_key=$(gpg --list-secret-keys --with-colons 2>/dev/null | awk -F: '/^ssb/ && $12 ~ /s/ {print $5; exit}')

  if [ -n "$signing_key" ]; then
    # Use GPG for signing. This will prompt for YubiKey PIN when signing
    log "signingkey" "YubiKey GPG key: $signing_key"
    $GIT_CMD user.signingkey "$signing_key"
    $GIT_CMD gpg.program "$gpg_path"
    $GIT_CMD commit.gpgsign true
    $GIT_CMD tag.gpgsign true
  else
    log "warning" "No YubiKey GPG signing key found - skipping commit signing configuration"
  fi
}

gc_lfs() {
  if command -v git-lfs >/dev/null 2>&1; then
    git lfs install
  fi
}

# Main script function

# Parse command line arguments
verbose=0
force=0

while getopts "fhv" opt; do
  case ${opt} in
  f) force=1 ;;
  v) verbose=1 ;;
  h) usage && exit 0 ;;
  \?) usage && exit 1 ;;
  esac
done
shift $((OPTIND - 1))

GIT_CONFIG_FILE=${1:-${GIT_CONFIG_FILE:-${HOME}/.gitconfig}}
GIT_CMD="git config --file $GIT_CONFIG_FILE"

if [ $force -eq 1 ]; then
  echo "Removing existing ${GIT_CONFIG_FILE}"
  rm "${GIT_CONFIG_FILE}"
fi
touch "${GIT_CONFIG_FILE}"

vlog "config file" "${GIT_CONFIG_FILE}"
gc_user
gc_credentials
gc_commitsigning
gc_tools
gc_lfs
