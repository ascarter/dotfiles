#!/bin/sh
#
# dotfiles management tool
#

set -eu

VERBOSE=0
FORCE=0
FORCE_ALL=0
QUIET=0

SCRIPT_DIR=$(dirname $(realpath "$0"))
DOTFILES_HOME=$(dirname ${SCRIPT_DIR})

# ANSI style (skip colors if NO_COLOR set or stdout not a tty)
if [ -t 1 ] && [ -z "${NO_COLOR:-}" ]; then
  BOLD=$(printf '\033[1m')
  RESET=$(printf '\033[0m')
else
  BOLD=''
  RESET=''
fi

log() {
  case $# in
  0) printf "\n" ;;
  1) printf "%s\n" "$1" ;;
  *)
    label="$1"
    shift
    printf "%s%-10s%s " "$BOLD" "$label" "$RESET"
    message="$1"
    shift
    printf "%s\n" "$message"

    if [ "$VERBOSE" -eq 1 ]; then
      for arg do
        [ -n "$arg" ] || continue
        printf "\t\t%s\n" "$arg"
      done
    fi
    ;;
  esac
}

vlog() {
  if [ "$VERBOSE" -eq 1 ]; then
    log "$@"
  fi
}

error() {
  printf "%s%-10s%s %s\n" "$BOLD" "error" "$RESET" "$*" >&2
  exit 1
}

reload_msg() {
  log "Restart your shell or run \`source ~/.zshenv\`"
}

usage() {
  cat <<'EOF'
dotfiles - manage dotfiles repository

Usage:
  dotfiles [options] <command>

Commands:
  init        Initialize dotfiles
  env         Export configuration for environment
  sync        Synchronize config
  unlink      Remove symlinks for config
  uninstall   Uninstall dotfiles
  status      Show status of dotfiles
  update      Update dotfiles repository

Options:
  -v          Enable verbose output
  -f          Force actions where applicable
  -h          Show this help message
EOF
}

# ------------------------------
# Helper functions
# ------------------------------

prompt() {
  if [ "$FORCE_ALL" -eq 1 ]; then
    return 0
  fi

  printf "%s (y/N/a) " "$1" > /dev/tty
  IFS= read -r choice < /dev/tty || choice=""
  case "$choice" in
  [yY]) return 0 ;;
  [a]) FORCE_ALL=1; return 0 ;;
  esac
  return 1
}

sync() {
  # Action to apply for each file
  # Actions: link | unlink | status
  action=${1:-status}

  # Synchronize config/ into XDG config home using git ls-files (tracked + untracked, excluding ignored); orphan detection retained
  XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}"
  SRC="${DOTFILES_HOME}/config/"
  DEST="${XDG_CONFIG_HOME}/"

  # Files and patterns to exclude from linking
  EXCLUDE_PATTERNS=".DS_Store Thumbs.db *.tmp .gitkeep"

  find_cmd="find \"$SRC\" -type f"
  for pattern in $EXCLUDE_PATTERNS; do
    find_cmd="$find_cmd -not -name \"$pattern\""
  done

  vlog "$action" "$SRC -> $DEST"

  log_sync() {
    label="$1"
    shift
    [ "$QUIET" -ne 1 ] && log "$label" "$@"
    case "$label" in
    link | unlink | ok) return 0 ;;
    *) return 1 ;;
    esac
  }

  link() {
    src_path="$1"
    dest_path="$2"
    rel_src="${src_path#$SRC}"

    if [ -e "$dest_path" ] && [ "$FORCE" -eq 1 ]; then
      unlink "$src_path" "$dest_path"
    fi

    if [ -e "$dest_path" ]; then
      status "$src_path" "$dest_path"
    else
      mkdir -p "$(dirname "$dest_path")"
      ln -s "$src_path" "$dest_path"
      log_sync "link" "$rel_src" "$dest_path -> $src_path"
    fi
  }

  unlink() {
    src_path="$1"
    dest_path="$2"
    rel_src="${src_path#$SRC}"

    compare_files() {
      if cmp -s "$dest_path" "$src_path"; then
        printf "matches source"
      else
        printf "differs from source"
      fi
    }

    if [ -L "$dest_path" ]; then
      existing_target=$(readlink "$dest_path")
      if [ "$existing_target" = "$src_path" ]; then
        rm "$dest_path"
        log_sync "unlink" "$rel_src" "removed $dest_path"
      elif [ "$FORCE" -eq 1 ] && prompt "Symlink $dest_path points to $existing_target instead of $rel_src. Remove?"; then
        rm "$dest_path"
        log_sync "unlink" "$rel_src" "deleted $dest_path -> $existing_target)"
      else
        log_sync "skip" "$rel_src" "ignore $dest_path -> $existing_target"
      fi
    else
      if [ -e "$dest_path" ]; then
        if [ "$FORCE" -eq 1 ] && prompt "$dest_path exists and $(compare_files "$src_path" "$dest_path"). Remove?"; then
          rm -rf "$dest_path"
          log_sync "deleted" "$rel_src" "deleted $dest_path"
        else
          log_sync "skip" "$dest_path"
        fi
      else
        log_sync "missing" "$dest_path"
      fi
    fi
  }

  status() {
    src_path="$1"
    dest_path="$2"
    rel_src="${src_path#$SRC}"

    if [ -L "$dest_path" ]; then
      existing_target=$(readlink "$dest_path")
      if [ "$existing_target" = "$src_path" ]; then
        if [ "$VERBOSE" -eq 1 ]; then
          log_sync "ok" "$rel_src"
        fi
      else
        log_sync "conflict" "$rel_src" "$dest_path -> $existing_target"
      fi
    else
      if [ -e "$dest_path" ]; then
        if cmp -s "$dest_path" "$src_path"; then
          log_sync "exists" "$rel_src" "$dest_path matches source"
        else
          log_sync "conflict" "$rel_src" "$dest_path differs from source"
        fi
      else
        log_sync "missing" "$rel_src" "no file at $dest_path"
      fi
    fi
  }

  eval "$find_cmd" | sort | (
    RC=0
    while read -r source_file; do
      target_file="${DEST}${source_file#$SRC}"
      if ! $action "$source_file" "$target_file"; then
        RC=1
      fi
    done
    return $RC
  )
}

# ------------------------------
# Commands
# ------------------------------

cmd_init() {
  zshenv="$HOME/.zshenv"

  # Check if already initialized
  if [ -f "${zshenv}" ] && grep -qE "eval \"\\\$\(.*/dotfiles env\)\"" "${zshenv}"; then
    log "init" "zsh already initialized"
    return 0
  fi
  # Create XDG directories
  XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}"
  XDG_DATA_HOME="${XDG_DATA_HOME:-$HOME/.local/share}"
  XDG_STATE_HOME="${XDG_STATE_HOME:-$HOME/.local/state}"
  XDG_CACHE_HOME="${XDG_CACHE_HOME:-$HOME/.cache}"
  XDG_BIN_HOME="${XDG_BIN_HOME:-$HOME/.local/bin}"

  mkdir -p "$XDG_CONFIG_HOME" "$XDG_DATA_HOME" "$XDG_STATE_HOME" "$XDG_CACHE_HOME" "$XDG_BIN_HOME"

  # Append bootstrap lines
  cat >> "${zshenv}" <<EOF
# dotfiles environment
eval "\$($SCRIPT_DIR/dotfiles env)"
EOF

  log "Initialized dotfiles for zsh"
  reload_msg
}

cmd_env() {
  # zsh environment setup
  cat <<'EOF'
export XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}"
export XDG_DATA_HOME="${XDG_DATA_HOME:-$HOME/.local/share}"
export XDG_STATE_HOME="${XDG_STATE_HOME:-$HOME/.local/state}"
export XDG_CACHE_HOME="${XDG_CACHE_HOME:-$HOME/.cache}"
export XDG_BIN_HOME="${XDG_BIN_HOME:-$HOME/.local/bin}"
export ZDOTDIR="${ZDOTDIR:-$XDG_CONFIG_HOME/zsh}"
export DOTFILES_HOME="${DOTFILES_HOME:-$XDG_DATA_HOME/dotfiles}"
typeset -U path
path=("$XDG_BIN_HOME" "$DOTFILES_HOME/bin" $path)
EOF
}

cmd_sync() {
  (sync link) && log "sync" "ok"
}

cmd_unlink() {
  (sync unlink) && log "unlink" "ok"
}

cmd_status() {
  (sync status) && log "status" "ok"
}

cmd_uninstall() {
  log "uninstall" "Removing dotfiles"
  cmd_unlink
}

cmd_update() {
  # Suppress output except errors
  QUIET=1

  # Unlink files before updating in case of structure changes
  if ! cmd_unlink; then
    error "Failed to unlink files before update"
  fi

  # Update the repository
  log "git" "Updating dotfiles repository"
  git -C "$DOTFILES_HOME" pull --ff-only

  # Resync files after update
  if ! cmd_sync; then
    error "Failed to resync files after update"
  fi

  reload_msg
}

main() {
  cmd="$1"
  shift

  case "$cmd" in
  env|init|sync|unlink|uninstall|status|update)
    cmd_$cmd "$@"
    ;;
  help)
    usage
    ;;
  *)
    if [ -n "$cmd" ]; then
      error "Unknown command: $cmd"
    fi
    usage
    exit 1
    ;;
  esac
}

# Parse command line options
while getopts "vfh" opt; do
  case $opt in
  v) VERBOSE=1 ;;
  f) FORCE=1 ;;
  h | \?) usage && exit 0 ;;
  esac
done
shift $((OPTIND - 1))

# Require subcommand
[ $# -gt 0 ] || {
  usage >&2
  exit 1
}

main "$@"
