#!/bin/sh
#
# dotfiles management tool
#

set -eu

VERBOSE=0
FORCE=0
FORCE_ALL=0

SCRIPT_DIR=$(dirname $(realpath "$0"))
DOTFILES_HOME=$(dirname ${SCRIPT_DIR})

log() {
  if [ "$#" -eq 0 ]; then
    printf "\n"
  elif [ "$#" -eq 1 ]; then
    printf "%s\n" "$1"
  else
    label="$1"
    message="${2:-}"
    printf "$(tput bold)%s$(tput sgr0) %s\n" "$label" "$message"
  fi
}

vlog() {
  if [ "$VERBOSE" -eq 1 ]; then
    log "$@"
  fi
}

error() {
  printf 'ERROR: %s\n' "$*" >&2
  exit 1
}

usage() {
  cat <<'EOF'
dotfiles - manage dotfiles repository

Usage:
  dotfiles [options] <command>

Commands:
  init        Initialize dotfiles
  env         Export configuration for environment
  sync        Synchronize config
  uninstall   Uninstall dotfiles
  status      Show status of dotfiles

Options:
  -v          Enable verbose output
  -f          Force actions where applicable
  -h          Show this help message
EOF
}

# ------------------------------
# Helper functions
# ------------------------------

prompt() {
  if [ "$FORCE_ALL" -eq 1 ]; then
    return 0
  fi

  printf "%s (y/N/a) " "$1" > /dev/tty
  IFS= read -r choice < /dev/tty || choice=""
  case "$choice" in
  [yY]) return 0 ;;
  [a]) FORCE_ALL=1; return 0 ;;
  esac
  return 1
}

create_symlink() {
  src_path="$1"
  dest_path="$2"
  dest_dir=$(dirname "$dest_path")

  # Create destination directory if it doesn't exist
  mkdir -p "$dest_dir"

  # If force is enabled, remove existing file/symlink first
  if [ "$FORCE" -eq 1 ]; then
    remove_symlink "$dest_path" "$src_path"
  fi

  # Create symlink if it doesn't already exist or points to a different source
  if [ -L "$dest_path" ]; then
    existing_target=$(readlink "$dest_path")
    if [ "$existing_target" != "$src_path" ]; then
      ln -sf "$src_path" "$dest_path"
      log "updated" "$dest_path -> $src_path"
    else
      log "ok" "$dest_path -> $src_path"
    fi
  elif [ -e "$dest_path" ]; then
    log "skip" "$dest_path"
  else
    ln -s "$src_path" "$dest_path"
    log "link" "$dest_path -> $src_path"
  fi
}

remove_symlink() {
  dest_path="$1"
  src_path="$2"

  if [ -L "$dest_path" ]; then
    existing_target=$(readlink "$dest_path")
    if [ "$existing_target" = "$src_path" ]; then
      rm "$dest_path"
      log "unlink" "$dest_path"
    else
      if [ "$FORCE" -eq 1 ]; then
        if prompt "Symlink $dest_path points to $existing_target instead of $src_path. Remove?"; then
          rm "$dest_path"
          log "force-unlink" "$dest_path (was -> $existing_target)"
          return 0
        fi
      fi
      log "skip" "$dest_path -> $existing_target (expected $src_path)"
    fi
  else
    if [ -e "$dest_path" ]; then
      if [ "$FORCE" -eq 1 ]; then
        if cmp -s "$dest_path" "$src_path"; then
          cmp_msg="matches source"
        else
          cmp_msg="differs from source"
        fi
        if prompt "$dest_path exists and $cmp_msg. Remove?"; then
          rm -rf "$dest_path"
          log "force-remove" "$dest_path"
          return 0
        fi
      fi
      log "skip" "$dest_path"
    else
      log "missing" "$dest_path"
    fi
  fi
}

check_symlink() {
  dest_path="$1"
  src_path="$2"

  if [ -L "$dest_path" ]; then
    existing_target=$(readlink "$dest_path")
    if [ "$existing_target" = "$src_path" ]; then
      log "ok" "$dest_path -> $src_path"
    else
      log "mismatch" "$dest_path -> $existing_target (expected $src_path)"
    fi
  else
    if [ -e "$dest_path" ]; then
      # Compare file contents
      # If they match, consider it "exists", else "mismatch"
      if cmp -s "$dest_path" "$src_path"; then
        log "exists" "$dest_path (matches source)"
      else
        log "mismatch" "$dest_path (differs from source)"
      fi
    else
      log "missing" "$dest_path"
    fi
  fi
}

sync() {
  # Action to apply for each file
  # Actions: link | unlink | status
  action=${1:-status}

  # Synchronize config/ into XDG config home using git ls-files (tracked + untracked, excluding ignored); orphan detection retained
  XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}"
  SRC="${DOTFILES_HOME}/config/"
  DEST="${XDG_CONFIG_HOME}/"

  # Files and patterns to exclude from linking
  EXCLUDE_PATTERNS=".DS_Store Thumbs.db *.tmp .gitkeep"

  find_cmd="find \"$SRC\" -type f"
  for pattern in $EXCLUDE_PATTERNS; do
    find_cmd="$find_cmd -not -name \"$pattern\""
  done

  log "$action" "$SRC -> $DEST"
  eval "$find_cmd" | sort | while read -r source_file; do
    target_file="${DEST}${source_file#$SRC}"
    vlog "$action" "$target_file -> $source_file"

    case "$action" in
    link)
      create_symlink "$source_file" "$target_file"
      ;;
    unlink)
      remove_symlink "$target_file" "$source_file"
      ;;
    status)
      check_symlink "$target_file" "$source_file"
      ;;
    *)
      error "Unknown action: $action"
      ;;
    esac
  done
}

# ------------------------------
# Commands
# ------------------------------

cmd_init() {
  zshenv="$HOME/.zshenv"

  # Check if already initialized
  if [ -f "${zshenv}" ] && grep -qE "eval \"\\\$\(.*/dotfiles env\)\"" "${zshenv}"; then
    log "init" "zsh already initialized"
    return 0
  fi
  # Create XDG directories
  XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}"
  XDG_DATA_HOME="${XDG_DATA_HOME:-$HOME/.local/share}"
  XDG_STATE_HOME="${XDG_STATE_HOME:-$HOME/.local/state}"
  XDG_CACHE_HOME="${XDG_CACHE_HOME:-$HOME/.cache}"
  XDG_BIN_HOME="${XDG_BIN_HOME:-$HOME/.local/bin}"

  mkdir -p "$XDG_CONFIG_HOME" "$XDG_DATA_HOME" "$XDG_STATE_HOME" "$XDG_CACHE_HOME" "$XDG_BIN_HOME"

  # Append bootstrap lines
  cat >> "${zshenv}" <<EOF
# dotfiles environment
eval "\$($SCRIPT_DIR/dotfiles env)"
EOF

  echo "Initialized dotfiles for zsh"
  echo "Restart your shell or run:"
  echo "   source ~/.zshenv"
}

cmd_env() {
  # zsh environment setup
  cat <<'EOF'
export XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}"
export XDG_DATA_HOME="${XDG_DATA_HOME:-$HOME/.local/share}"
export XDG_STATE_HOME="${XDG_STATE_HOME:-$HOME/.local/state}"
export XDG_CACHE_HOME="${XDG_CACHE_HOME:-$HOME/.cache}"
export XDG_BIN_HOME="${XDG_BIN_HOME:-$HOME/.local/bin}"
export ZDOTDIR="${ZDOTDIR:-$XDG_CONFIG_HOME/zsh}"
export DOTFILES_HOME="${DOTFILES_HOME:-$XDG_DATA_HOME/dotfiles}"
typeset -U path
path=("$XDG_BIN_HOME" "$DOTFILES_HOME/bin" $path)
EOF
}

cmd_sync() {
  sync link
}

cmd_uninstall() {
  log "uninstall" "Removing dotfiles"
  sync unlink
}

[ $# -gt 0 ] || {
  usage >&2
  exit 1
}

cmd_status() {
  sync status
}

main() {
  cmd="$1"
  shift

  case "$cmd" in
  env|init|sync|uninstall|status)
    cmd_$cmd "$@"
    ;;
  help)
    usage
    ;;
  *)
    if [ -n "$cmd" ]; then
      error "Unknown command: $cmd"
    fi
    usage
    exit 1
    ;;
  esac
}

# Parse command line options
while getopts "vfh" opt; do
  case $opt in
  v) VERBOSE=1 ;;
  f) FORCE=1 ;;
  h | \?) usage && exit 0 ;;
  esac
done
shift $((OPTIND - 1))

main "$@"
