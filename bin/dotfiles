#!/bin/sh
#
# dotfiles management tool
#

set -eu

VERBOSE=0
FORCE=0
FORCE_ALL=0
QUIET=0

DOTFILES_HOME=$(realpath $(dirname $(realpath "$0"))/..)
DOTFILES_SCRIPTS_DIR="${DOTFILES_HOME}/scripts"

# ANSI strings
if [[ -t 1 ]]; then
  tty_escape() { printf "\033[%sm" "$1"; }
else
  tty_escape() { :; }
fi
tty_reset="$(tty_escape 0)"
tty_mkbold() { tty_escape "1;$1"; }
tty_underline="$(tty_escape "4;39")"
tty_blue="$(tty_mkbold 34)"
tty_red="$(tty_mkbold 31)"
tty_bold="$(tty_mkbold 39)"

log() {
  case $# in
  0) printf "\n" ;;
  1) printf "%s\n" "$1" ;;
  *)
    label="$1"
    shift
    printf "${tty_bold}%s${tty_reset} " "${label}"
    message="$1"
    shift
    printf "%s\n" "$message"

    if [ "$VERBOSE" -eq 1 ]; then
      for arg; do
        [ -n "$arg" ] || continue
        printf "\t\t%s\n" "$arg"
      done
    fi
    ;;
  esac
}

vlog() {
  if [ "$VERBOSE" -eq 1 ]; then
    log "$@"
  fi
}

error() {
  printf "${tty_red}error${tty_reset} %s\n" "$*" >&2
}

warn() {
  label="${1:-warning}"
  shift
  printf "${tty_blue}%s${tty_reset} %s\n" "$label" "$*" >&2
}

abort() {
  error "$@"
  exit 1
}

ensure() {
  if ! "$@"; then
    abort "command failed: $*"
  fi
}

success() {
  log "$@"
  log "Restart your shell or run \`source ~/.zshenv\`"
  exit 0
}

usage() {
  cat <<'EOF'
dotfiles - manage dotfiles repository

Usage:
  dotfiles [options] <command>

Commands:
  init        Initialize dotfiles
  env         Export configuration for environment
  sync        Synchronize config
  uninstall   Uninstall dotfiles
  status      Show status of dotfiles
  update      Update dotfiles repository
  edit        Edit dotfiles repository using $EDITOR

Options:
  -v          Enable verbose output
  -f          Force actions where applicable
  -h          Show this help message
EOF
}

# ------------------------------
# Helper functions
# ------------------------------

prompt() {
  if [ "$FORCE_ALL" -eq 1 ]; then
    return 0
  fi

  printf "%s (y/N/a) " "$1" >/dev/tty
  IFS= read -r choice </dev/tty || choice=""
  case "$choice" in
  [yY]) return 0 ;;
  [a])
    FORCE_ALL=1
    return 0
    ;;
  esac
  return 1
}

platform_id() {
  case "$(uname -s)" in
  Darwin)
    echo "macos"
    ;;
  Linux)
    if [ -f /etc/os-release ]; then
      . /etc/os-release
      echo "${ID}"
    else
      echo "linux-unknown"
    fi
    ;;
  *)
    echo "unknown"
    ;;
  esac
}

run_script() {
  script_name="$1"
  shift
  script_path="${DOTFILES_SCRIPTS_DIR}/host/${script_name}.sh"

  [ -f "$script_path" ] || abort "script not found: $script_name"

  vlog "script" "running $script_name"
  ensure sh "$script_path" "$@"
}

sync() {
  # Action to apply for each file
  # Actions: link | unlink | status
  action=${1:-status}

  # Synchronize config/ into XDG config home using git ls-files (tracked + untracked, excluding ignored); orphan detection retained
  XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}"
  SRC="${DOTFILES_HOME}/config/"
  DEST="${XDG_CONFIG_HOME}/"

  # Files and patterns to exclude from linking
  EXCLUDE_PATTERNS=".DS_Store Thumbs.db *.tmp .gitkeep"

  find_cmd="find \"$SRC\" -type f"
  for pattern in $EXCLUDE_PATTERNS; do
    find_cmd="$find_cmd -not -name \"$pattern\""
  done

  vlog "$action" "$SRC -> $DEST"

  log_sync() {
    label="$1"
    shift
    case "$label" in
    link | unlink | ok)
      [ "$QUIET" -ne 1 ] && log "$label" "$@"
      return 0
      ;;
    *)
      [ "$QUIET" -ne 1 ] && warn "$label" "$@"
      return 1
      ;;
    esac
  }

  link() {
    src_path="$1"
    dest_path="$2"
    rel_src="${src_path#$SRC}"

    if [ -e "$dest_path" ] && [ "$FORCE" -eq 1 ]; then
      unlink "$src_path" "$dest_path"
    fi

    if [ -e "$dest_path" ]; then
      status "$src_path" "$dest_path"
    else
      mkdir -p "$(dirname "$dest_path")"
      ln -s "$src_path" "$dest_path"
      log_sync "link" "$rel_src" "$dest_path -> $src_path"
    fi
  }

  unlink() {
    src_path="$1"
    dest_path="$2"
    rel_src="${src_path#$SRC}"

    compare_files() {
      if cmp -s "$dest_path" "$src_path"; then
        printf "matches source"
      else
        printf "differs from source"
      fi
    }

    if [ -L "$dest_path" ]; then
      existing_target=$(readlink "$dest_path")
      if [ "$existing_target" = "$src_path" ]; then
        rm "$dest_path"
        log_sync "unlink" "$rel_src" "removed $dest_path"
      elif [ "$FORCE" -eq 1 ] && prompt "Symlink $dest_path points to $existing_target instead of $rel_src. Remove?"; then
        rm "$dest_path"
        log_sync "unlink" "$rel_src" "deleted $dest_path -> $existing_target)"
      else
        log_sync "skip" "$rel_src" "ignore $dest_path -> $existing_target"
      fi
    else
      if [ -e "$dest_path" ]; then
        if [ "$FORCE" -eq 1 ] && prompt "$dest_path exists and $(compare_files "$src_path" "$dest_path"). Remove?"; then
          rm -rf "$dest_path"
          log_sync "deleted" "$rel_src" "deleted $dest_path"
        else
          log_sync "skip" "$dest_path"
        fi
      else
        log_sync "missing" "$dest_path"
      fi
    fi
  }

  status() {
    src_path="$1"
    dest_path="$2"
    rel_src="${src_path#$SRC}"

    if [ -L "$dest_path" ]; then
      existing_target=$(readlink "$dest_path")
      if [ "$existing_target" = "$src_path" ]; then
        if [ "$VERBOSE" -eq 1 ]; then
          log_sync "ok" "$rel_src"
        fi
      else
        log_sync "conflict" "$rel_src" "$dest_path -> $existing_target"
      fi
    else
      if [ -e "$dest_path" ]; then
        if cmp -s "$dest_path" "$src_path"; then
          log_sync "exists" "$rel_src" "$dest_path matches source"
        else
          log_sync "conflict" "$rel_src" "$dest_path differs from source"
        fi
      else
        log_sync "missing" "$rel_src" "no file at $dest_path"
      fi
    fi
  }

  eval "$find_cmd" | sort | (
    RC=0
    while read -r source_file; do
      target_file="${DEST}${source_file#$SRC}"
      if ! $action "$source_file" "$target_file"; then
        RC=1
      fi
    done
    return $RC
  )
}

# ------------------------------
# Commands
# ------------------------------

cmd_init() {
  # Create XDG directories
  : "${XDG_BIN_HOME:=$HOME/.local/bin}"
  : "${XDG_CONFIG_HOME:=$HOME/.config}"
  : "${XDG_DATA_HOME:=$HOME/.local/share}"
  : "${XDG_STATE_HOME:=$HOME/.local/state}"
  : "${XDG_CACHE_HOME:=$HOME/.cache}"

  for dir in "$XDG_BIN_HOME" "$XDG_CONFIG_HOME" "$XDG_DATA_HOME" "$XDG_STATE_HOME" "$XDG_CACHE_HOME"; do
    vlog "xdg" "ensuring $dir exists"
    [ -d "$dir" ] || mkdir -p "$dir"
  done

  # Check if zsh initialized
  zshenv="$HOME/.zshenv"
  if [ ! -f "${zshenv}" ] || ! grep -qE 'eval "\$\([^"]*bin/dotfiles env\)"' "${zshenv}"; then
    # Append bootstrap lines
    cat >>"${zshenv}" <<EOF
# dotfiles environment
eval "\$(${DOTFILES_HOME}/bin/dotfiles env)"
EOF
  fi

  cmd_sync

  run_script $(platform_id)
  run_script "homebrew"
  run_script "gitconfig"

  success "Initialized dotfiles for zsh"
}

cmd_env() {
  # zsh environment setup
  cat <<'EOF'
export XDG_BIN_HOME="${XDG_BIN_HOME:-$HOME/.local/bin}"
export XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}"
export XDG_DATA_HOME="${XDG_DATA_HOME:-$HOME/.local/share}"
export XDG_STATE_HOME="${XDG_STATE_HOME:-$HOME/.local/state}"
export XDG_CACHE_HOME="${XDG_CACHE_HOME:-$HOME/.cache}"
export ZDOTDIR="${ZDOTDIR:-$XDG_CONFIG_HOME/zsh}"
export DOTFILES_HOME="${DOTFILES_HOME:-$XDG_DATA_HOME/dotfiles}"
typeset -U path
path=("$XDG_BIN_HOME" "$DOTFILES_HOME/bin" $path)
EOF
}

cmd_sync() {
  (sync link) && log "sync" "ok"
}

cmd_status() {
  (sync status) && log "status" "ok"
}

cmd_uninstall() {
  (sync unlink) && log "unlink" "ok"
}

cmd_update() {
  # Suppress output except errors
  QUIET=1

  # Unlink files before updating in case of structure changes
  cmd_uninstall || abort "failed to unlink files before update"

  # Update the repository
  log "git" "Updating dotfiles repository"
  git -C "$DOTFILES_HOME" pull --ff-only

  # Resync files after update
  cmd_sync || abort "failed to resync files after update"

  success "dotfiles updated"
}

cmd_edit() {
  "$EDITOR" "$DOTFILES_HOME"
}

main() {
  cmd="$1"
  shift

  case "$cmd" in
  env | init | sync | unlink | uninstall | status | update | edit)
    cmd_$cmd "$@"
    ;;
  help)
    usage
    ;;
  *)
    if [ -n "$cmd" ]; then
      error "Unknown command: $cmd"
    fi
    usage
    exit 1
    ;;
  esac
}

# Parse command line options
while getopts "vfh" opt; do
  case $opt in
  v) VERBOSE=1 ;;
  f) FORCE=1 ;;
  h | \?) usage && exit 0 ;;
  esac
done
shift $((OPTIND - 1))

# Require subcommand
[ $# -gt 0 ] || {
  usage >&2
  exit 1
}

main "$@"
