#!/bin/sh
#
# dotfiles management tool
#

set -eu

VERBOSE=0
FORCE=0
FORCE_ALL=0

SCRIPT_DIR=$(dirname $(realpath "$0"))
DOTFILES_HOME=$(dirname ${SCRIPT_DIR})

# ANSI style (skip colors if NO_COLOR set or stdout not a tty)
if [ -t 1 ] && [ -z "${NO_COLOR:-}" ]; then
  BOLD=$(printf '\033[1m')
  RESET=$(printf '\033[0m')
else
  BOLD=''
  RESET=''
fi

log() {
  case $# in
  0) printf "\n" ;;
  1) printf "%s\n" "$1" ;;
  *)
    label="$1"
    shift
    printf "%s%-10s%s " "$BOLD" "$label" "$RESET"
    message="$1"
    shift
    printf "%s\n" "$message"

    if [ "$VERBOSE" -eq 1 ]; then
      for arg do
        [ -n "$arg" ] || continue
        printf "\t\t%s\n" "$arg"
      done
    fi
    ;;
  esac
}

vlog() {
  if [ "$VERBOSE" -eq 1 ]; then
    log "$@"
  fi
}

error() {
  printf 'ERROR: %s\n' "$*" >&2
  exit 1
}

usage() {
  cat <<'EOF'
dotfiles - manage dotfiles repository

Usage:
  dotfiles [options] <command>

Commands:
  init        Initialize dotfiles
  env         Export configuration for environment
  sync        Synchronize config
  unlink      Remove symlinks for config
  uninstall   Uninstall dotfiles
  status      Show status of dotfiles

Options:
  -v          Enable verbose output
  -f          Force actions where applicable
  -h          Show this help message
EOF
}

# ------------------------------
# Helper functions
# ------------------------------

prompt() {
  if [ "$FORCE_ALL" -eq 1 ]; then
    return 0
  fi

  printf "%s (y/N/a) " "$1" > /dev/tty
  IFS= read -r choice < /dev/tty || choice=""
  case "$choice" in
  [yY]) return 0 ;;
  [a]) FORCE_ALL=1; return 0 ;;
  esac
  return 1
}

sync() {
  # Action to apply for each file
  # Actions: link | unlink | status
  action=${1:-status}

  # Synchronize config/ into XDG config home using git ls-files (tracked + untracked, excluding ignored); orphan detection retained
  XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}"
  SRC="${DOTFILES_HOME}/config/"
  DEST="${XDG_CONFIG_HOME}/"

  # Files and patterns to exclude from linking
  EXCLUDE_PATTERNS=".DS_Store Thumbs.db *.tmp .gitkeep"

  find_cmd="find \"$SRC\" -type f"
  for pattern in $EXCLUDE_PATTERNS; do
    find_cmd="$find_cmd -not -name \"$pattern\""
  done

  link() {
    src_path="$1"
    dest_path="$2"
    rel_src="${src_path#$SRC}"

    if [ -e "$dest_path" ] && [ "$FORCE" -eq 1 ]; then
      unlink "$src_path" "$dest_path"
    fi

    if [ -e "$dest_path" ]; then
      status "$src_path" "$dest_path"
    else
      mkdir -p "$(dirname "$dest_path")"
      ln -s "$src_path" "$dest_path"
      log "link" "$rel_src" "$dest_path -> $src_path"
    fi
  }

  unlink() {
    src_path="$1"
    dest_path="$2"
    rel_src="${src_path#$SRC}"

    compare_files() {
      if cmp -s "$dest_path" "$src_path"; then
        printf "matches source"
      else
        printf "differs from source"
      fi
    }

    if [ -L "$dest_path" ]; then
      existing_target=$(readlink "$dest_path")
      if [ "$existing_target" = "$src_path" ]; then
        rm "$dest_path"
        log "unlink" "$rel_src" "removed $dest_path"
      elif [ "$FORCE" -eq 1 ] && prompt "Symlink $dest_path points to $existing_target instead of $rel_src. Remove?"; then
        rm "$dest_path"
        log "unlink" "$rel_src" "deleted $dest_path -> $existing_target)"
      else
        log "skip" "$rel_src" "ignore $dest_path -> $existing_target"
      fi
    else
      if [ -e "$dest_path" ]; then
        if [ "$FORCE" -eq 1 ] && prompt "$dest_path exists and $(compare_files "$src_path" "$dest_path"). Remove?"; then
          rm -rf "$dest_path"
          log "deleted" "$rel_src" "deleted $dest_path"
        else
          log "skip" "$dest_path"
        fi
      else
        log "missing" "$dest_path"
      fi
    fi
  }

  status() {
    src_path="$1"
    dest_path="$2"
    rel_src="${src_path#$SRC}"

    if [ -L "$dest_path" ]; then
      existing_target=$(readlink "$dest_path")
      if [ "$existing_target" = "$src_path" ]; then
        log "ok" "$rel_src"
      else
        log "conflict" "$rel_src" "$dest_path -> $existing_target"
      fi
    else
      if [ -e "$dest_path" ]; then
        if cmp -s "$dest_path" "$src_path"; then
          log "exists" "$rel_src" "$dest_path matches source"
        else
          log "conflict" "$rel_src" "$dest_path differs from source"
        fi
      else
        log "missing" "$rel_src" "no file at $dest_path"
      fi
    fi
  }

  eval "$find_cmd" | sort | while read -r source_file; do
    target_file="${DEST}${source_file#$SRC}"
    vlog "$action" "$target_file -> $source_file"
    $action "$source_file" "$target_file"
  done
}

# ------------------------------
# Commands
# ------------------------------

cmd_init() {
  zshenv="$HOME/.zshenv"

  # Check if already initialized
  if [ -f "${zshenv}" ] && grep -qE "eval \"\\\$\(.*/dotfiles env\)\"" "${zshenv}"; then
    log "init" "zsh already initialized"
    return 0
  fi
  # Create XDG directories
  XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}"
  XDG_DATA_HOME="${XDG_DATA_HOME:-$HOME/.local/share}"
  XDG_STATE_HOME="${XDG_STATE_HOME:-$HOME/.local/state}"
  XDG_CACHE_HOME="${XDG_CACHE_HOME:-$HOME/.cache}"
  XDG_BIN_HOME="${XDG_BIN_HOME:-$HOME/.local/bin}"

  mkdir -p "$XDG_CONFIG_HOME" "$XDG_DATA_HOME" "$XDG_STATE_HOME" "$XDG_CACHE_HOME" "$XDG_BIN_HOME"

  # Append bootstrap lines
  cat >> "${zshenv}" <<EOF
# dotfiles environment
eval "\$($SCRIPT_DIR/dotfiles env)"
EOF

  echo "Initialized dotfiles for zsh"
  echo "Restart your shell or run:"
  echo "   source ~/.zshenv"
}

cmd_env() {
  # zsh environment setup
  cat <<'EOF'
export XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}"
export XDG_DATA_HOME="${XDG_DATA_HOME:-$HOME/.local/share}"
export XDG_STATE_HOME="${XDG_STATE_HOME:-$HOME/.local/state}"
export XDG_CACHE_HOME="${XDG_CACHE_HOME:-$HOME/.cache}"
export XDG_BIN_HOME="${XDG_BIN_HOME:-$HOME/.local/bin}"
export ZDOTDIR="${ZDOTDIR:-$XDG_CONFIG_HOME/zsh}"
export DOTFILES_HOME="${DOTFILES_HOME:-$XDG_DATA_HOME/dotfiles}"
typeset -U path
path=("$XDG_BIN_HOME" "$DOTFILES_HOME/bin" $path)
EOF
}

cmd_sync() {
  (sync link)
}

cmd_unlink() {
  (sync unlink)
}

cmd_status() {
  (sync status)
}

cmd_uninstall() {
  log "uninstall" "Removing dotfiles"
  cmd_unlink
}

main() {
  cmd="$1"
  shift

  case "$cmd" in
  env|init|sync|unlink|uninstall|status)
    cmd_$cmd "$@"
    ;;
  help)
    usage
    ;;
  *)
    if [ -n "$cmd" ]; then
      error "Unknown command: $cmd"
    fi
    usage
    exit 1
    ;;
  esac
}

# Parse command line options
while getopts "vfh" opt; do
  case $opt in
  v) VERBOSE=1 ;;
  f) FORCE=1 ;;
  h | \?) usage && exit 0 ;;
  esac
done
shift $((OPTIND - 1))

# Require subcommand
[ $# -gt 0 ] || {
  usage >&2
  exit 1
}

main "$@"
