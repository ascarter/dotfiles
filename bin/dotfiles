#!/bin/sh
#
# dotfiles - dispatcher for managing this dotfiles repository
#

set -eu

VERBOSE=0

SCRIPT_DIR=$(dirname $(realpath "$0"))
DOTFILES_HOME=$(dirname ${SCRIPT_DIR})

error() {
  printf 'ERROR: %s\n' "$*" >&2
  exit 1
}

usage() {
  cat <<'EOF'
dotfiles - manage dotfiles repository

Usage:
  dotfiles [options] <command>

Commands:
  init        Initialize dotfiles (.zshenv entry)
  env         Print export statements for environment
  sync        Synchronize config/ -> $XDG_CONFIG_HOME
EOF
}

# ------------------------------
# Command functions
# ------------------------------

cmd_init() {
  zshenv="$HOME/.zshenv"

  # Check if already initialized
  if [ -f "${zshenv}" ] && grep -qE "eval \"\\\$\(.*/dotfiles env\)\"" "${zshenv}"; then
    echo "zsh already initialized"
    return 0
  fi

  # Append bootstrap lines
  cat >> "${zshenv}" <<EOF
# dotfiles environment
eval "\$($SCRIPT_DIR/dotfiles env)"
EOF

  echo "Initialized dotfiles for zsh"
  echo "Restart your shell or run:"
  echo "   source ~/.zshenv"
}

cmd_env() {
  # zsh environment setup
  cat <<'EOF'
export XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}"
export XDG_DATA_HOME="${XDG_DATA_HOME:-$HOME/.local/share}"
export XDG_STATE_HOME="${XDG_STATE_HOME:-$HOME/.local/state}"
export XDG_CACHE_HOME="${XDG_CACHE_HOME:-$HOME/.cache}"
export XDG_BIN_HOME="${XDG_BIN_HOME:-$HOME/.local/bin}"
export ZDOTDIR="${ZDOTDIR:-$XDG_CONFIG_HOME/zsh}"
export DOTFILES_HOME="${DOTFILES_HOME:-$XDG_DATA_HOME/dotfiles}"
typeset -U path
path=("$XDG_BIN_HOME" "$DOTFILES_HOME/bin" $path)
EOF
}

print_section() {
  # Usage: print_section "Header:" "$list"
  # Prints section only if list (newline-delimited) is non-empty.
  header="$1"
  data="$2"
  if [ -n "$data" ]; then
    echo
    echo "$header"
    printf '%b' "$data" | while IFS= read -r f; do
      [ -n "$f" ] && echo "  $f"
    done
  fi
}
cmd_sync() {
  # Synchronize config/ into XDG config home using git ls-files (tracked + untracked, excluding ignored); orphan detection retained
  XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}"
  CONFIG_SRC="${DOTFILES_HOME}/config/"
  CONFIG_DEST="${XDG_CONFIG_HOME}/"

  command -v rsync >/dev/null 2>&1 || error "rsync not installed"
  command -v git >/dev/null 2>&1 || error "git not installed"
  [ -d "${CONFIG_SRC}" ] || error "Source config directory not found: ${CONFIG_SRC}"

  echo "Sync ${CONFIG_SRC} -> ${CONFIG_DEST}"

  RSYNC_FLAGS="-av"
  changes=$(git -C "${DOTFILES_HOME}" ls-files -co --exclude-standard config \
    | sed 's:^config/::' \
    | rsync ${RSYNC_FLAGS} -ain --files-from=- "${CONFIG_SRC}" "${CONFIG_DEST}" \
    | awk 'NR==1 && $0 ~ /^sending incremental file list$/ {next} /^[.]/ {next} /^$/ {next} {print}' \
    | sed -n '/^>f/p;/^\*deleting /p')

  added_list=""
  changed_list=""
  added_count=0
  changed_count=0
  deleted_count=0  # placeholder (no deletions performed)
  deleted_list=""

  while IFS= read -r line; do
    [ -z "$line" ] && continue
    case "$line" in
      '>f'*|'*deleting '*)
        ;;
      *)
        continue
        ;;
    esac
    code=${line%% *}
    file=${line#* }
    # Detect deletions (not active unless rsync run with --delete)
    if printf "%s" "$code" | grep -q '^\*deleting'; then
      deleted_list="${deleted_list}${file}\n"
      deleted_count=$((deleted_count+1))
      continue
    fi
    # Classify purely by destination existence: if file not present in destination it's an addition; otherwise a change
    if [ ! -e "${CONFIG_DEST}${file}" ]; then
      added_list="${added_list}${file}\n"
      added_count=$((added_count+1))
    else
      changed_list="${changed_list}${file}\n"
      changed_count=$((changed_count+1))
    fi
  done <<EOF
$changes
EOF

  orphan_list=""
  # Orphan detection
  orphan_count=0
  for srcsub in "${CONFIG_SRC}"*/; do
    [ -d "$srcsub" ] || continue
    name=$(basename "$srcsub")
    destsub="${CONFIG_DEST}${name}/"
    [ -d "$destsub" ] || continue
    while IFS= read -r dfile; do
      rel="${dfile#"$destsub"}"
      if [ ! -f "${srcsub}${rel}" ]; then
        if git -C "${DOTFILES_HOME}" check-ignore -q "config/${name}/${rel}"; then
          continue
        fi
        orphan_list="${orphan_list}${name}/${rel}\n"
        orphan_count=$((orphan_count+1))
      fi
    done <<EOF
$(find "$destsub" -type f)
EOF
  done

  echo "Added $added_count, Changed $changed_count, Orphaned $orphan_count"

  # Nothing to do (no changes and no orphans)
  if [ $changed_count -eq 0 ] && [ $added_count -eq 0 ] && [ $orphan_count -eq 0 ]; then
    echo "Up to date."
    return 0
  fi

  # Print sections only when non-empty
  print_section "Changed files:" "$changed_list"
  print_section "Added files:" "$added_list"
  print_section "Orphaned files:" "$orphan_list"
  # If only orphans and no changes, skip prompt
  if [ -n "$orphan_list" ] && [ -z "$changed_list" ] && [ -z "$added_list" ]; then
    return 0
  fi

  echo
  printf "Proceed with sync (apply added/changed) to %s? [y/N] " "${CONFIG_DEST}"
  read ans
  case "$ans" in
    y|Y|yes|YES)
      git -C "${DOTFILES_HOME}" ls-files -co --exclude-standard config \
        | sed 's:^config/::' \
        | rsync ${RSYNC_FLAGS} --files-from=- "${CONFIG_SRC}" "${CONFIG_DEST}"
      echo "Config synced to ${CONFIG_DEST}"
      ;;
    *)
      echo "Sync aborted"
      ;;
  esac
}

[ $# -gt 0 ] || {
  usage >&2
  exit 1
}
COMMAND="$1"
shift

case "$COMMAND" in
env)   cmd_env ;;
init)  cmd_init ;;
sync)  cmd_sync ;;
*)     error "Unknown command: $COMMAND" ;;
esac
